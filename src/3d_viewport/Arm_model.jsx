/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 arm_model.glb 
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { Euler, Quaternion, Vector3 } from 'three'
import { useSpring, animated } from '@react-spring/three'
import { useSelector } from 'react-redux'
import { map } from '../helpers/helpers'



export function ARM_model(props) {
  const group = useRef()
  const servoAngles = useSelector(state => state.arm.get_servoAngles)
  console.log(servoAngles, "servoAngles")
  const [s3_angle, setS3Angle] = useState(0);
  const [s4_angle, setS4Angle] = useState(0);


  // const spring = useSpring({
  //   s3_angle: servoAngles[2],
  //   config: { mass: 1, tension: 120, friction: 14 , precision: 0.0001}
  // });

  // const { s3_angle: animatedAngle } = spring;


  useEffect(() => {
    process_s1angle(servoAngles[0]);
    process_s2angle(servoAngles[1]);
    process_s3angle(servoAngles[2]);
    set_s4angle(servoAngles[3],servoAngles[1],servoAngles[0]);
  }, [servoAngles]);




  const { nodes, materials, animations } = useGLTF('/arm_model.glb')
  const { actions, name } = useAnimations(animations, group)
   const rot =[nodes.b_s1.rotation,nodes.b_s2.rotation,nodes.b_s3.rotation, nodes.baseB.rotation]
   const [r1,r2,r3,base]= [...rot];
   console.log(base)



  const process_s1angle = (s1_angle) => {
    
    const angle = map(s1_angle, 0, 180, -60, 60);
    if (nodes.b_s1) {
      const euler = new Euler(-(angle * Math.PI / 180), 0, 0, 'XYZ');
      const quaternion = new Quaternion().setFromEuler(euler);
      nodes.b_s1.quaternion.copy(quaternion);
    }
  }

  const process_s2angle = (s2_angle) => {
    nodes.b_s2.position.set(0, 7, -0.8888888888888888);
    const angle = map(s2_angle, 0, 180, -60, 60);
    if (nodes.b_s2) {
      const euler = new Euler(-(angle * Math.PI / 180), -( 9.4), 0, 'XYZ');
      const quaternion = new Quaternion().setFromEuler(euler);
      nodes.b_s2.quaternion.copy(quaternion);
    }
  }


  // set the angle of Bone (b_s3) to the angle of servo 3 in the redux store 
  const process_s3angle = (s3_angle) => {
    const angle = map(s3_angle, 0, 180, -60, 60);
    if (nodes.b_s3) {
      const euler = new Euler(-(angle * Math.PI / 180), 0, 0, 'XYZ');
      const quaternion = new Quaternion().setFromEuler(euler);
      nodes.b_s3.quaternion.copy(quaternion);
    }
  }



  const set_s4angle = (s4_angle,y,x) => {
     const angle = map(s4_angle, 0, 180, -180, 0);
    // if (nodes.baseB) {
    //   const euler = new Euler(-0.214273996986359, angle * Math.PI / 180,-8.852837682223599e-17, 'XYZ');
    //   const quaternion = new Quaternion().setFromEuler(euler);
    //   nodes.baseB.quaternion.copy(quaternion);
    // }
    // snodes.b_s2.position.set(0, 7, -0.8888888888888888);
    console.log("pos",nodes.b_s1.position);
    
  }



  return (
    <>

      <animated.mesh>
        <group ref={group} {...props} dispose={null}>


          <group name="Scene">
            <group name="Armature002" position={[0, 0, 0]} rotation={[0, 1, 0]}>
              <primitive object={nodes.baseB} />


            </group>
          </group>
        </group>
      </animated.mesh>
    </>
  )
}

useGLTF.preload('/arm_model.glb')
